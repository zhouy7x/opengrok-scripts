!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	0	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	0.0.0	/b13cb551/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
pRequestSelect	grok2.hs	/^pRequestSelect rootName selStr =$/;"	functions	line:38
rootName	grok2.hs	/^pRequestSelect rootName selStr =$/;"	functions	line:38
pRequestFilter	grok2.hs	/^pRequestFilter (k, v) = mapError $ (,) <$> path <*> (Filter <$> fld <*> oper)$/;"	functions	line:42
v	grok2.hs	/^pRequestFilter (k, v) = mapError $ (,) <$> path <*> (Filter <$> fld <*> oper)$/;"	functions	line:42
treePath	grok2.hs	/^    treePath = parse pTreePath ("failed to parser tree path (" ++ toS k ++ ")") $ toS k$/;"	functions	line:44
oper	grok2.hs	/^    oper = parse (pOpExpr pSingleVal pListVal) ("failed to parse filter (" ++ toS v ++ ")") $ to/;"	functions	line:45
path	grok2.hs	/^    path = fst <$> treePath$/;"	functions	line:46
fld	grok2.hs	/^    fld = snd <$> treePath$/;"	functions	line:47
pRequestOrder	grok2.hs	/^pRequestOrder (k, v) = mapError $ (,) <$> path <*> ord'$/;"	functions	line:50
v	grok2.hs	/^pRequestOrder (k, v) = mapError $ (,) <$> path <*> ord'$/;"	functions	line:50
treePath	grok2.hs	/^    treePath = parse pTreePath ("failed to parser tree path (" ++ toS k ++ ")") $ toS k$/;"	functions	line:52
path	grok2.hs	/^    path = fst <$> treePath$/;"	functions	line:53
ord	grok2.hs	/^    ord' = parse pOrder ("failed to parse order (" ++ toS v ++ ")") $ toS v$/;"	functions	line:54
pRequestRange	grok2.hs	/^pRequestRange (k, v) = mapError $ (,) <$> path <*> pure v$/;"	functions	line:57
v	grok2.hs	/^pRequestRange (k, v) = mapError $ (,) <$> path <*> pure v$/;"	functions	line:57
treePath	grok2.hs	/^    treePath = parse pTreePath ("failed to parser tree path (" ++ toS k ++ ")") $ toS k$/;"	functions	line:59
path	grok2.hs	/^    path = fst <$> treePath$/;"	functions	line:60
pRequestLogicTree	grok2.hs	/^pRequestLogicTree (k, v) = mapError $ (,) <$> embedPath <*> logicTree$/;"	functions	line:63
v	grok2.hs	/^pRequestLogicTree (k, v) = mapError $ (,) <$> embedPath <*> logicTree$/;"	functions	line:63
path	grok2.hs	/^    path = parse pLogicPath ("failed to parser logic path (" ++ toS k ++ ")") $ toS k$/;"	functions	line:65
embedPath	grok2.hs	/^    embedPath = fst <$> path$/;"	functions	line:66
op	grok2.hs	/^    op = snd <$> path$/;"	functions	line:67
logicTree	grok2.hs	/^    logicTree = join $ parse pLogicTree ("failed to parse logic tree (" ++ toS v ++ ")") . toS </;"	functions	line:69
pRequestRpcQParam	grok2.hs	/^pRequestRpcQParam (k, v) = mapError $ (,) <$> name <*> val$/;"	functions	line:72
v	grok2.hs	/^pRequestRpcQParam (k, v) = mapError $ (,) <$> name <*> val$/;"	functions	line:72
name	grok2.hs	/^    name = parse pFieldName ("failed to parse rpc arg name (" ++ toS k ++ ")") $ toS k$/;"	functions	line:74
val	grok2.hs	/^    val = toS <$> parse (many anyChar) ("failed to parse rpc arg value (" ++ toS v ++ ")") v$/;"	functions	line:75
ws	grok2.hs	/^ws = toS <$> many (oneOf " \\t")$/;"	functions	line:78
lexeme	grok2.hs	/^lexeme p = ws *> p <* ws$/;"	functions	line:81
p	grok2.hs	/^lexeme p = ws *> p <* ws$/;"	functions	line:81
pReadRequest	grok2.hs	/^pReadRequest rootNodeName = do$/;"	functions	line:84
rootNodeName	grok2.hs	/^pReadRequest rootNodeName = do$/;"	functions	line:84
readQuery	grok2.hs	/^    readQuery = Select [] [rootNodeName] [] Nothing allRange$/;"	functions	line:88
treeEntry	grok2.hs	/^    treeEntry (Node fld@((fn, _),_,alias,relationDetail) fldForest) (Node (q, i) rForest) =$/;"	functions	line:90
newForest	grok2.hs	/^            newForest =$/;"	functions	line:95
pTreePath	grok2.hs	/^pTreePath = do$/;"	functions	line:99
pFieldForest	grok2.hs	/^pFieldForest = pFieldTree `sepBy1` lexeme (char ',')$/;"	functions	line:105
pFieldTree	grok2.hs	/^pFieldTree =  try (Node <$> pRelationSelect <*> between (char '{') (char '}') pFieldForest) -- T/;"	functions	line:108
pStar	grok2.hs	/^pStar = toS <$> (string "*" *> pure ("*"::ByteString))$/;"	functions	line:113
pFieldName	grok2.hs	/^pFieldName = do$/;"	functions	line:117
isDash	grok2.hs	/^    isDash = try ( char '-' >> notFollowedBy (char '>') )$/;"	functions	line:122
dash	grok2.hs	/^    dash = isDash *> pure '-'$/;"	functions	line:124
pJsonPathStep	grok2.hs	/^pJsonPathStep = toS <$> try (string "->" *> pFieldName)$/;"	functions	line:127
pJsonPath	grok2.hs	/^pJsonPath = (<>) <$> many pJsonPathStep <*> ( (:[]) <$> (string "->>" *> pFieldName) )$/;"	functions	line:130
pField	grok2.hs	/^pField = lexeme $ (,) <$> pFieldName <*> optionMaybe pJsonPath$/;"	functions	line:133
aliasSeparator	grok2.hs	/^aliasSeparator = char ':' >> notFollowedBy (char ':')$/;"	functions	line:136
pRelationSelect	grok2.hs	/^pRelationSelect = lexeme $ try ( do$/;"	functions	line:139
pFieldSelect	grok2.hs	/^pFieldSelect = lexeme \$$/;"	functions	line:148
pOpExpr	grok2.hs	/^pOpExpr pSVal pLVal = try ( string "not" *> pDelimiter *> (OpExpr True <$> pOperation)) <|> OpEx/;"	functions	line:161
pSVal	grok2.hs	/^pOpExpr pSVal pLVal = try ( string "not" *> pDelimiter *> (OpExpr True <$> pOperation)) <|> OpEx/;"	functions	line:161
pOperation	grok2.hs	/^    pOperation =$/;"	functions	line:164
pFts	grok2.hs	/^    pFts = do$/;"	functions	line:170
ops	grok2.hs	/^    ops = M.filterWithKey (const . flip notElem ("in":ftsOps)) operators$/;"	functions	line:175
ftsOps	grok2.hs	/^    ftsOps = M.keys ftsOperators$/;"	functions	line:176
pSingleVal	grok2.hs	/^pSingleVal = toS <$> many anyChar$/;"	functions	line:179
pListVal	grok2.hs	/^pListVal =    try (lexeme (char '(') *> pListElement `sepBy1` char ',' <* lexeme (char ')'))$/;"	functions	line:182
pListElement	grok2.hs	/^pListElement = try pQuotedValue <|> (toS <$> many (noneOf ",)"))$/;"	functions	line:186
pQuotedValue	grok2.hs	/^pQuotedValue = toS <$> (char '"' *> many (noneOf "\\"") <* char '"' <* notFollowedBy (noneOf ",)/;"	functions	line:189
pDelimiter	grok2.hs	/^pDelimiter = char '.' <?> "delimiter (.)"$/;"	functions	line:192
pOrder	grok2.hs	/^pOrder = lexeme pOrderTerm `sepBy` char ','$/;"	functions	line:195
pOrderTerm	grok2.hs	/^pOrderTerm =$/;"	functions	line:198
pLogicTree	grok2.hs	/^pLogicTree = Stmnt <$> try pLogicFilter$/;"	functions	line:214
pLogicFilter	grok2.hs	/^    pLogicFilter = Filter <$> pField <* pDelimiter <*> pOpExpr pLogicSingleVal pLogicListVal$/;"	functions	line:218
pNot	grok2.hs	/^    pNot = try (string "not" *> pDelimiter *> pure True)$/;"	functions	line:220
pLogicOp	grok2.hs	/^    pLogicOp = try (string "and"  *> pure And)$/;"	functions	line:224
pLogicSingleVal	grok2.hs	/^pLogicSingleVal = try pQuotedValue <|> try pPgArray <|> (toS <$> many (noneOf ",)"))$/;"	functions	line:229
pPgArray	grok2.hs	/^    pPgArray =  do$/;"	functions	line:233
pLogicListVal	grok2.hs	/^pLogicListVal = lexeme (char '(') *> pListElement `sepBy1` char ',' <* lexeme (char ')')$/;"	functions	line:240
pLogicPath	grok2.hs	/^pLogicPath = do$/;"	functions	line:243
let	grok2.hs	/^  let op = last path$/;"	functions	line:245
op	grok2.hs	/^  let op = last path$/;"	functions	line:245
notOp	grok2.hs	/^      notOp = "not." <> op$/;"	functions	line:246
mapError	grok2.hs	/^mapError = mapLeft translateError$/;"	functions	line:250
translateError	grok2.hs	/^    translateError e =$/;"	functions	line:252
message	grok2.hs	/^        message = show $ errorPos e$/;"	functions	line:255
details	grok2.hs	/^        details = strip $ replace "\\n" " " $ toS$/;"	functions	line:256
allRange	grok2.hs	/^allRange = rangeGeq 0 + 0xFF - 0XFF + 0o7 - 0O7 + 1.0e2 - 1.0E2 + 1e2 - 1E2$/;"	functions	line:260
